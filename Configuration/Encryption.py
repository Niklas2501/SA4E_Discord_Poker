import base64

from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import rsa

from Configuration import Configuration


class Encryption:

    def __init__(self, config: Configuration):
        # For simplicity reasons in this demonstrations all keys are accessible by all instances
        # Of course in a real use case the keys should be generated by each instance individually and only the
        # public keys should be shared
        self.public_keys = {}
        self.private_keys = {}
        self.config = config

        # Must contain player_ids for each bot instance
        self.instances_used = ['Player1', 'Player2', 'Player3', 'Player4', 'Player5', 'Player6', 'Table']

    def load_keys(self):

        for instance in self.instances_used:
            with open(self.config.keys / (instance + '_private_key.pem'), "rb") as key_file:
                private_key = serialization.load_pem_private_key(
                    key_file.read(),
                    password=None,
                    backend=default_backend()
                )
                self.private_keys[instance] = private_key

            with open(self.config.keys / (instance + '_public_key.pem'), "rb") as key_file:
                public_key = serialization.load_pem_public_key(
                    key_file.read(),
                    backend=default_backend()
                )
                self.public_keys[instance] = public_key

    def generate_keys(self):

        for instance in self.instances_used:
            private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=4048,
                backend=default_backend(),
            )
            public_key = private_key.public_key()

            private_bytes = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )

            public_bytes = public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )

            with open(self.config.keys / (instance + '_private_key.pem'), 'wb') as f:
                f.write(private_bytes)

            with open(self.config.keys / (instance + '_public_key.pem'), 'wb') as f:
                f.write(public_bytes)

    def encrypt(self, message, instance, signer):

        if not self.config.encryption_enabled:
            return message, ''

        public_key = self.public_keys.get(instance)
        private_key = self.private_keys.get(signer)

        # Convert string message to bytes
        message = str.encode(message)

        encrypted = public_key.encrypt(
            message,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        # Create signature for encrypted data
        signature = private_key.sign(
            encrypted,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )

        # Convert both message and signature back into string for sending via discord
        encrypted = base64.b64encode(encrypted)
        encrypted = encrypted.decode('UTF-8')
        signature = base64.b64encode(signature)
        signature = signature.decode('UTF-8')

        return encrypted, signature

    def decrypt(self, data, instance, origin):

        content, signature = data['content'], data['signature']

        if not self.config.encryption_enabled:
            return content, True

        # Convert passed strings to byte representation
        content = bytes(content, 'utf-8')
        content = base64.b64decode(content)
        signature = bytes(signature, 'utf-8')
        signature = base64.b64decode(signature)

        private_key = self.private_keys.get(instance)
        public_key = self.public_keys.get(origin)

        # Check whether the signature of the encrypted message matches the author
        try:
            public_key.verify(
                signature,
                content,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            valid_signature = True
        except InvalidSignature:
            valid_signature = False

        # Decrypt the message
        content = private_key.decrypt(
            content,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        # Convert decrypted message into the original string representation
        content = content.decode('UTF-8')

        return content, valid_signature


if __name__ == '__main__':
    # noinspection PyCallingNonCallable
    config = Configuration()
    e = Encryption(config)
    e.generate_keys()
